# [2. 词法分析](https://docs.python.org/3/reference/lexical_analysis.html)

Python程序由*解析器*读取。输入到解析器中的是由*词法分析器*生成的标记流。本章描述词法分析器如何把一个文件拆分成标记。

Python将程序文本作为Unicode码点读取；源文件的编码由编码声明给出，默认值为UTF-8，详细信息参考[**PEP 3120**](https://www.python.org/dev/peps/pep-3120/)。如果源文件不能被解码，将引发[SyntaxError](https://docs.python.org/3/library/exceptions.html#SyntaxError)异常。

## [2.1. 行结构](https://docs.python.org/3/reference/lexical_analysis.html#line-structure)

Python程序被拆分为多个*逻辑行*。

### [2.1.1. 逻辑行](https://docs.python.org/3/reference/lexical_analysis.html#logical-lines)

逻辑行的结束由 NEWLINE 标记表示。除非语法允许 NEWLINE（e.g. 复合语句的语句之间），否则语句不能跨越逻辑行的边界。逻辑行由一个或多个*物理行*构建，并遵循显式或隐式*行连接*规则。

### [2.1.2. 物理行](https://docs.python.org/3/reference/lexical_analysis.html#physical-lines)

物理行是一个 end-of-line 序列终止的字符序列。在源文件中，可以使用任何标准平台的行终止序列——Unix形式使用 ASCII 的 LF（换行），windows形式使用 ASCII 序列 CR LF（回车，换行），或者Macintosh过去使用的 ACSII 的 CR（回车）字符。

在嵌入Python时，对于换行符源代码字符串，应该使用标准C的习惯传递给 Python API（`\n`字符，相当于 ASCII LF，作为行终止符）。

### [2.1.3. 注释](https://docs.python.org/3/reference/lexical_analysis.html#comments)

注释以井号`#`开头，以该物理行结束处中止。（注释字符串并不包含`#`)。注释表示逻辑行的结尾，除非调用隐式行连接。语法忽略注释；注释不是标记。

### [2.1.4. 编码声明](https://docs.python.org/3/reference/lexical_analysis.html#encoding-declarations)

如果Python脚本的第一行或第二行注释匹配正则表达式`coding[=:]\s*([-\w.]+)`，该注释将作为编码声明处理；该表达式的第一个分组给出了该源文件的编码。编码声明必须出现在自己的一行上。如果它处于第二行，第一行也必须为纯注释行。编码声明的推荐格式为

```python
# -*- coding: <编码名> -*-
```

这是被GNU Emacs认可的，以及

```python
# vim:fileencoding=<编码名>
```

这是被Bram Moolenaar 的 VIM认可的。

如果没有找到编码声明，将被默认声明为 UTF-8。此外，如果该文件开始的几个字节是UTF-8的字节顺序标记（`b'\xef\xbb\xbf'`）。该编码声明为 UTF-8。（这个特性也被微软的**notepad**和其它编辑器支持。）

如果编码被声明，该编码必须能被Python识别。该编码被用于所有的词法分析，包括字符串字面值，注释和标识符。

### [2.1.5. 显式行连接](https://docs.python.org/3/reference/lexical_analysis.html#explicit-line-joining)

两条或更多的物理行可以使用反斜杠（\）连接为逻辑行。如下：当一个物理行以反斜杠结尾并且它不处于字符串字面量或注释中，它将连接之后的至同一逻辑行，并删去反斜杠以及行尾字符。例：

```python
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # 看起来是一个合法日期
        return 1
```

以反斜杠结尾的行不能包含注释。反斜杠不会继续注释。除了字符串面面值（即，除了字符串面值之外的标记不能使用反斜杠在物理行上分割）之外，反斜杠不继续标记。反斜杠在字符串外面的行上是非法的。A backslash is illegal elsewhere on a line outside a string literal.

### [2.1.6. 隐式行连接](https://docs.python.org/3/reference/lexical_analysis.html#implicit-line-joining)

圆括号，方括号或花括号中的表达式可以在不使用反斜杠的情况下在多个物理行上分割。例如：

```python
month_names = ['Januari', 'Februari', 'Maart',      # 这些是荷兰语
               'April',   'Mei',      'Juni',       # 中的12个月份
               'Juli',    'Augustus', 'September',
               'Oktober', 'November', 'December']
```

Implicitly continued lines can carry comments. The indentation of the continuation lines is not important. Blank continuation lines are allowed. There is no NEWLINE token between implicit continuation lines. Implicitly continued lines can also occur within triple-quoted strings (see below); in that case they cannot carry comments.

隐式行连接可以带有注释。连续行的缩进并不重要。允许空白连续行。隐式连续行之间没有NEWLINE标记。隐式连续的行，也可能发生在三引号字符串 （见下文）；在这种情况下他们不能带有注释。

### [2.1.7. 空白行](https://docs.python.org/3/reference/lexical_analysis.html#blank-lines)

A logical line that contains only spaces, tabs, formfeeds and possibly a comment, is ignored (i.e., no NEWLINE token is generated). During interactive input of statements, handling of a blank line may differ depending on the implementation of the read-eval-print loop. In the standard interactive interpreter, an entirely blank logical line (i.e. one containing not even whitespace or a comment) terminates a multi-line statement.

### [2.1.8. 缩进](https://docs.python.org/3/reference/lexical_analysis.html#indentation)

Leading whitespace (spaces and tabs) at the beginning of a logical line is used to compute the indentation level of the line, which in turn is used to determine the grouping of statements.

Tabs are replaced (from left to right) by one to eight spaces such that the total number of characters up to and including the replacement is a multiple of eight (this is intended to be the same rule as used by Unix). The total number of spaces preceding the first non-blank character then determines the line’s indentation. Indentation cannot be split over multiple physical lines using backslashes; the whitespace up to the first backslash determines the indentation.

Indentation is rejected as inconsistent if a source file mixes tabs and spaces in a way that makes the meaning dependent on the worth of a tab in spaces; a TabError is raised in that case.

Cross-platform compatibility note: because of the nature of text editors on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for the indentation in a single source file. It should also be noted that different platforms may explicitly limit the maximum indentation level.

A formfeed character may be present at the start of the line; it will be ignored for the indentation calculations above. Formfeed characters occurring elsewhere in the leading whitespace have an undefined effect (for instance, they may reset the space count to zero).

The indentation levels of consecutive lines are used to generate INDENT and DEDENT tokens, using a stack, as follows.

Before the first line of the file is read, a single zero is pushed on the stack; this will never be popped off again. The numbers pushed on the stack will always be strictly increasing from bottom to top. At the beginning of each logical line, the line’s indentation level is compared to the top of the stack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token is generated. If it is smaller, it must be one of the numbers occurring on the stack; all numbers on the stack that are larger are popped off, and for each number popped off a DEDENT token is generated. At the end of the file, a DEDENT token is generated for each number remaining on the stack that is larger than zero.

Here is an example of a correctly (though confusingly) indented piece of Python code:

```python
def perm(l):
        # Compute the list of all permutations of l
    if len(l) <= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r
```

The following example shows various indentation errors:

```python
def perm(l):                       # error: first line indented
for i in range(len(l)):             # error: not indented
   s = l[:i] + l[i+1:]
       p = perm(l[:i] + l[i+1:])   # error: unexpected indent
       for x in p:
               r.append(l[i:i+1] + x)
           return r                # error: inconsistent dedent
```

(Actually, the first three errors are detected by the parser; only the last error is found by the lexical analyzer — the indentation of return r does not match a level popped off the stack.)
